import { payload } from 'payload';
import Parser from 'rss-parser';

const parser = new Parser();

export default async function rssFetcher() {
  try {
    console.log('üîÑ Starting RSS feed fetcher...');
    
    // Get active feeds
    const feeds = await payload.find({
      collection: 'feeds',
      where: {
        active: {
          equals: true,
        },
      },
    });

    console.log(`üì∞ Found ${feeds.docs.length} active feeds`);

    for (const feed of feeds.docs) {
      try {
        console.log(`üì° Processing feed: ${feed.name} (${feed.url})`);
        
        // Fetch RSS feed content
        const response = await fetch(feed.url);
        const xml = await response.text();
        
        // Parse RSS feed
        const feedData = await parser.parseString(xml);
        
        console.log(`üìÑ Found ${feedData.items?.length || 0} items in feed`);
        
        // Process each item
        const maxItems = feed.maxItems || 10;
        const itemsToProcess = feedData.items?.slice(0, maxItems) || [];
        
        for (const item of itemsToProcess) {
          try {
            // Check if item already exists
            const existingContent = await payload.find({
              collection: 'rawContents',
              where: {
                originalUrl: {
                  equals: item.link,
                },
              },
              limit: 1,
            });

            if (existingContent.docs.length > 0) {
              console.log(`‚è≠Ô∏è  Item already exists: ${item.title}`);
              continue;
            }

            // Create raw content
            const rawContent = await payload.create({
              collection: 'rawContents',
              data: {
                title: item.title || 'Untitled',
                content: item.content || item.contentSnippet || '',
                excerpt: item.contentSnippet || item.title || '',
                source: 'RSS',
                status: 'draft',
                reviewed: false,
                autoGenerated: true,
                createdByAI: false,
                originalUrl: item.link || '',
                metadata: {
                  feedName: feed.name,
                  feedUrl: feed.url,
                  pubDate: item.pubDate,
                  author: item.creator || item.author,
                  categories: item.categories || [],
                  guid: item.guid,
                },
                tags: feed.tags || [],
                categories: feed.categories || [],
              },
            });

            console.log(`‚úÖ Created raw content: ${rawContent.title}`);
          } catch (itemError) {
            console.error(`‚ùå Error processing item ${item.title}:`, itemError);
          }
        }
        
        // Update feed status
        await payload.update({
          collection: 'feeds',
          id: feed.id,
          data: {
            lastFetchedAt: new Date().toISOString(),
            lastFetchStatus: 'success',
            lastFetchError: '',
          },
        });
        
        console.log(`‚úÖ Processed feed: ${feed.name}`);
      } catch (feedError) {
        console.error(`‚ùå Error processing feed ${feed.name}:`, feedError);
        
        // Update feed error status
        await payload.update({
          collection: 'feeds',
          id: feed.id,
          data: {
            lastFetchedAt: new Date().toISOString(),
            lastFetchStatus: 'error',
            lastFetchError: feedError instanceof Error ? feedError.message : 'Unknown error',
          },
        });
      }
    }
    
    console.log('‚úÖ RSS fetcher completed');
  } catch (error) {
    console.error('‚ùå RSS fetcher error:', error);
  }
}